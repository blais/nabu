<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.3.10: http://docutils.sourceforge.net/" />
<title>Nabu: Writing an Extractor</title>
<link rel="stylesheet" href="../style.css" type="text/css" />
</head>
<body>

<div id="project-header">
  <a href="/"><img src="/home/project-header.png" id="logo"></a>
  <div id="project-home"><a href="..">Project Home</a></div>
</div>

<div class="document" id="nabu-writing-an-extractor">
<h1 class="title">Nabu: Writing an Extractor</h1>
<div class="abstract topic">
<p class="topic-title first">Abstract</p>
<p>This document shows an example of writing an extractor for identifying and
saving parts of documents from within a Nabu server.</p>
</div>
<div class="contents topic" id="contents">
<p class="topic-title first"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#introduction" id="id5" name="id5">Introduction</a></li>
<li><a class="reference" href="#example-application-extracting-books-from-field-lists" id="id6" name="id6">Example Application: Extracting Books from Field Lists</a></li>
<li><a class="reference" href="#looking-at-the-document-structure" id="id7" name="id7">Looking at the Document Structure</a></li>
<li><a class="reference" href="#the-extractor-and-the-extractorstorage" id="id8" name="id8">The Extractor and the ExtractorStorage</a></li>
<li><a class="reference" href="#example-code" id="id9" name="id9">Example code</a><ul>
<li><a class="reference" href="#imports" id="id10" name="id10">Imports</a></li>
<li><a class="reference" href="#the-extractor-class" id="id11" name="id11">The Extractor Class</a></li>
<li><a class="reference" href="#the-extractorstorage-class" id="id12" name="id12">The ExtractorStorage Class</a></li>
</ul>
</li>
<li><a class="reference" href="#testing-your-extractor" id="id13" name="id13">Testing Your Extractor</a></li>
<li><a class="reference" href="#publisher-handler-configuration-code" id="id14" name="id14">Publisher Handler Configuration Code</a></li>
<li><a class="reference" href="#complete-source-code" id="id15" name="id15">Complete Source Code</a></li>
<li><a class="reference" href="#final-notes" id="id16" name="id16">Final Notes</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id5" name="introduction">Introduction</a></h1>
<p>Nabu offers a framework for the extraction of meaningful portions of documents
into structured storage (e.g. database tables).  This extraction will generally
be customized for each end application and therefore we anticipate that people
will write their own extractors.</p>
<p>This document provides an example of that.  It aims at demonstrating the
simplicity of the task.</p>
<p>Note that we are reusing the SQLObject wrapper library which we already use for
storing Nabu's uploaded sources.  SQLObject is a very flexible library that
provides a pythonic object mapping to SQL database tables, with support for most
popular open source databases.</p>
</div>
<div class="section" id="example-application-extracting-books-from-field-lists">
<h1><a class="toc-backref" href="#id6" name="example-application-extracting-books-from-field-lists">Example Application: Extracting Books from Field Lists</a></h1>
<p>For our example, we will examine the task of extracting information for book
references.  Imagine that we want to be able to put field lists that are book
references, scattered all over our documents, something that looks more or less
like BibTeX entries, for example:</p>
<pre class="literal-block">
:book:
:title: National Geographic Photography Field Guide 2nd Edition:
        Secrets to Making Great Pictures
:author: Peter Burian, Bob Caputo
:isbn: 079225676X
:review:

  Excellent diversified advice from top photographers.  The book
  manages to pack lots of relevant content in a small format.  It
  contains a nice section on composition, which is what originally
  attracted me to it.  As per usual, I found the digital
  photography section useless, but for the most part, the
  information available in this book is of great value.  This is
  the best general book about photography that I've read.
</pre>
<p>Since the docutils parser works recursively, those field lists can be located
anywhere within the document <a class="footnote-reference" href="#id3" id="id1" name="id1">[1]</a>, for example, in an item list, e.g.:</p>
<pre class="literal-block">
Recent books read:

- :title: Animal Farm
  :author: George Orwell
  :url: http://www.online-literature.com/orwell/animalfarm/
  :review:

     A classic work.

- :title: Free Culture
  :author: Lawrence Lessig
  :url: http://www.amazon.com/o/ASIN/0143034650/

- :title: A Scanner Darkly
  :author: Philip K. Dick
  :isbn: 0679736654

...
</pre>
<p>We would like to avoid having to say that the field list is for a book; it would
be nice if the parser could just figure that out by itself.  For example, the
empty <tt class="docutils literal"><span class="pre">:book:</span></tt> field in the first example above should not be mandatory for
the book reference to be detected.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p>One additional detail is that the field lists should be separate.  In
reStructuredText, fields are allowed to have whitespace between them, so
that:</p>
<pre class="literal-block">
:title: A Scanner Darkly

:author: Philip K. Dick

:isbn: 0679736654
:url: http://www.amazon.com/o/ASIN/0679736654/
</pre>
<p>is a single field list.  This means that you cannot separate field lists with
just whitespace.  I'm using an itemized list in the previous example, but
other document structures could be used as well (see the <a class="reference" href="http://docutils.sourceforge.net/docs/ref/doctree.html">docutils document
tree</a> a list of constructs that get recognized in reStructuredText).  This
example exhibits a subtlety that may arise when you choose which structures
will be parsed: you have to think about how the docutils parser will
represent the data in the tree of nodes.  For example, the following would
not work because it gets parsed as a single field list:</p>
<pre class="last literal-block">
:title: Free Culture
:author: Lawrence Lessig
:url: http://www.amazon.com/o/ASIN/0143034650/

:title: A Scanner Darkly
:author: Philip K. Dick
:isbn: 0679736654
</pre>
</div>
</div>
<div class="section" id="looking-at-the-document-structure">
<h1><a class="toc-backref" href="#id7" name="looking-at-the-document-structure">Looking at the Document Structure</a></h1>
<p>Here is a pseudo-xml rendering of how the above example gets parsed by docutils
into a tree of nodes.  This is the tree that we will have to visit to extract
the references from.  You can use docutils' <tt class="docutils literal"><span class="pre">rst2pseudoxml.py</span></tt> tool to
generate such a tree to be able to visualize the document structure, and to help
design and write your extractor/visitor:</p>
<pre class="literal-block">
&lt;document source=&quot;/tmp/example.txt&quot;&gt;
    &lt;paragraph&gt;
        Recent books read:
    &lt;bullet_list bullet=&quot;-&quot;&gt;
        &lt;list_item&gt;
            &lt;field_list&gt;
                &lt;field&gt;
                    &lt;field_name&gt;
                        title
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            Animal Farm
                &lt;field&gt;
                    &lt;field_name&gt;
                        author
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            George Orwell
                &lt;field&gt;
                    &lt;field_name&gt;
                        url
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            &lt;reference refuri=&quot;http://www.online-literature.com/orwell/animalfarm/&quot;&gt;
                                http://www.online-literature.com/orwell/animalfarm/
                &lt;field&gt;
                    &lt;field_name&gt;
                        review
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            A classic work.
        &lt;list_item&gt;
            &lt;field_list&gt;
                &lt;field&gt;
                    &lt;field_name&gt;
                        title
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            Free Culture
                &lt;field&gt;
                    &lt;field_name&gt;
                        author
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            Lawrence Lessig
                &lt;field&gt;
                    &lt;field_name&gt;
                        url
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            &lt;reference refuri=&quot;http://www.amazon.com/o/ASIN/0143034650/&quot;&gt;
                                http://www.amazon.com/o/ASIN/0143034650/
        &lt;list_item&gt;
            &lt;field_list&gt;
                &lt;field&gt;
                    &lt;field_name&gt;
                        title
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            A Scanner Darkly
                &lt;field&gt;
                    &lt;field_name&gt;
                        author
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            Philip K. Dick
                &lt;field&gt;
                    &lt;field_name&gt;
                        isbn
                    &lt;field_body&gt;
                        &lt;paragraph&gt;
                            0679736654
</pre>
</div>
<div class="section" id="the-extractor-and-the-extractorstorage">
<h1><a class="toc-backref" href="#id8" name="the-extractor-and-the-extractorstorage">The Extractor and the ExtractorStorage</a></h1>
<p>In order to extract some stuff from our documents, we need to provide at least
two classes:</p>
<ol class="arabic">
<li><p class="first">an extractor class, which is essentially a class derived from the docutils
<tt class="docutils literal"><span class="pre">Transform</span></tt> class, whose role is to visit the parsed document tree and to
find the stuff that it wants to find.  In our example, this class will be
running a visitor to look for docutils field lists nodes and it will check
the field names to find out if they are for books;</p>
</li>
<li><p class="first">an extractor storage class, whose role is to put detected book references
into whatever storage is desired.  It is decoupled from the extractor so that
the same extractor algorithm can support different storage mechanisms.  This
storage object is normally provided by the publisher handler script in its
configuration.</p>
<p>Typically, we would store the references in a database, or convert them into
BibTeX format and store them sequentially in a file for later use.</p>
</li>
</ol>
</div>
<div class="section" id="example-code">
<h1><a class="toc-backref" href="#id9" name="example-code">Example code</a></h1>
<p>All the code for implementing the book algorithm above fits neatly in a short
file.  Let's name it <tt class="docutils literal"><span class="pre">book.py</span></tt>.</p>
<div class="section" id="imports">
<h2><a class="toc-backref" href="#id10" name="imports">Imports</a></h2>
<p>We start our Python script with a brief description and some imports:</p>
<pre class="literal-block">
#!/usr/bin/env python
&quot;&quot;&quot;
Extract book entries.
&quot;&quot;&quot;

# other imports
from sqlobject import *

# nabu imports
from nabu import extract
from nabu.extractors.flvis import FieldListVisitor
</pre>
<p>We import symbols from SQLObject since we will use that to access a database
table to store our references into.  In addition, we import the <tt class="docutils literal"><span class="pre">nabu.extract</span></tt>
module which contains the base class that we need.  We also import a utility
class that knows how to visit docutils field lists <a class="footnote-reference" href="#id4" id="id2" name="id2">[2]</a>.</p>
</div>
<div class="section" id="the-extractor-class">
<h2><a class="toc-backref" href="#id11" name="the-extractor-class">The Extractor Class</a></h2>
<p>We then define the extractor class, which is a docutils <tt class="docutils literal"><span class="pre">Transform</span></tt>:</p>
<pre class="literal-block">
class BookExtractor(extract.Extractor):
    &quot;&quot;&quot;
    Transform that looks at field lists and that heuristically attempts
    to find references to books.  For example,

      :title: National Geographic Photography Field Guide 2nd Edition:
              Secrets to Making Great Pictures
      :author: Peter Burian, Bob Caputo
      :url: http://www.amazon.com/o/ASIN/079225676X/
      :review:

        Excellent diversified advice from top photographers.  The book
        manages to pack lots of relevant content in a small format.  It
        contains a nice section on composition, which is what originally
        attracted me to it.  As per usual, I found the digital
        photography section useless, but for the most part, the
        information available in this book is of great value.  This is
        the best general book about photography that I've read.

    The heuristic looks at an empty :book: field, an :ISBN: field, or
    some list that has an author and a title. See the Book class below to
    find out which fields are stored.
    &quot;&quot;&quot;

    default_priority = 900
</pre>
<p>Note that we put the full description in the docstring of the extractor class
rather than in the module docstring because the Nabu publisher program can
concatenate all the document strings of the extractors configured in the publish
handler CGI script and return that to the client, so that people who publish
content to a specific Nabu store can get an idea of what structures are
configured on the server (see the <tt class="docutils literal"><span class="pre">--help-transforms</span></tt> option to the Nabu
publisher program).</p>
<p>We also set the default priority that will specify the order in which the
extractors get to run.  This is important for extractors which modify the
document tree (the document tree can be stored and then served on a web server
just like extracted content--in fact, there is a trivial extractor provided that
does just that.  This can be easily leveraged to implement a Wiki or a Blog).</p>
<p>We then implement the <tt class="docutils literal"><span class="pre">apply()</span></tt> method which is called by docutils, after it
sets the <tt class="docutils literal"><span class="pre">.document</span></tt> attribute on the extractor (that is part of how
transforms are run by docutils):</p>
<pre class="literal-block">
...
    def apply( self, **kwargs ):
        self.unid, self.storage = kwargs['unid'], kwargs['storage']

        v = FieldListVisitor(self.document)
        v.initialize()
        self.document.walk(v)
        v.finalize()
</pre>
<p>The keyword arguments are always the unique id for the source document and the
extractor storage object that is configured on the publisher handler.</p>
<p>Note that we use a special FieldListVisitor class that we've built to simplify
visiting generic field lists.  You could use any of the docutils visitors here
instead.  We run the visitor on the document by calling the <tt class="docutils literal"><span class="pre">walk()</span></tt> method.
This special visitor accumulates all the field lists in the document into a
dictionary that we then process and implement our heuristic to find the field
lists that match our criteria:</p>
<pre class="literal-block">
...
        for flist in v.getfieldlists():
            book = 0
            # if there is an empty book field, this is explicitly a book.
            if 'book' in flist and not flist['book'].strip():
                book = 1
            # if there is an ISBN number, then it is *definitely* a book.
            elif 'isbn' in flist:
                book = 1
            # if there is an author and a title
            elif 'author' in flist and 'title' in flist:
                book = 1

            if book:
                self.store(flist) # store the book
</pre>
<p>Next, we implement a store method that converts the field value nodes returned
by the <tt class="docutils literal"><span class="pre">FieldListVisitor</span></tt> into Unicode text and calls our associated storage
object to actually put the data somewhere:</p>
<pre class="literal-block">
...
    def store( self, flist ):
        emap = {}
        for k, v in flist.iteritems():
            emap[k] = v.astext()

        self.storage.store(self.unid, emap)
</pre>
<p>That's it for the extractor class!</p>
</div>
<div class="section" id="the-extractorstorage-class">
<h2><a class="toc-backref" href="#id12" name="the-extractorstorage-class">The ExtractorStorage Class</a></h2>
<p>Before we write the extractor storage class, we will introduce a third class,
which is used to define a database table into which to store the book
references. This is due to our use of SQLObject to access the database, it uses
classes to define the schema of the tables we access.  This class will be used
by the extractor storage object.</p>
<pre class="literal-block">
class Book(SQLObject):
    &quot;&quot;&quot;
    Storage for book information.
    &quot;&quot;&quot;
    unid = StringCol(notNull=1)

    title = UnicodeCol()
    author = UnicodeCol()
    year = UnicodeCol()
    url = UnicodeCol()
    review = UnicodeCol()
</pre>
<p>The fields are self-explanatory.  We store all this information in as unicode
strings to be able to support exotic character sets.</p>
<p>Note that we declared a <tt class="docutils literal"><span class="pre">unid</span></tt> field that is required not to be null.  This is
used to be able to clear the objects from the database before a source document
is reprocessed.  All information extracted from a document is required to be
associated with the source document using this unique id so that when documents
change we can correctly remove the old information extracted from it before
filling it up again with the new.</p>
<p>Next, we write the extractor storage class:</p>
<pre class="literal-block">
class BookStorage(extract.SQLObjectExtractorStorage):
    &quot;&quot;&quot;
    Book storage.
    &quot;&quot;&quot;

    sqlobject_classes = [Book]

    def store( self, unid, *args ):
        data, = args
        Book( unid=unid,
              title=data.get('title', ''),
              author=data.get('author'),
              year=data.get('year', ''),
              url=data.get('url', ''),
              review=data.get('review', '') )
</pre>
<p>Here we derive it from the special <tt class="docutils literal"><span class="pre">SQLObjectExtractorStorage</span></tt> that Nabu
provides for storing stuff in databases using SQLObject.  Knowing which schemas
the storage class uses, this base class simply implements the protocol to
initialize the database connection for the wrapper objects, implements the
protocol for clearing objects extracted from a specific document, and to reset
the tables (see the source code if desired, it is very very simple).  The
expected schema classes are specified in the class attribute
<tt class="docutils literal"><span class="pre">sqlobject_classes</span></tt>.</p>
<p>The class basically just creates a new book reference entry by instantiating the
<tt class="docutils literal"><span class="pre">Book</span></tt> schema class.  It fills in default empty values for the entries that
have not been found by the extractor (we could have implemented this in the
extractor itself--this is by choice of contract between the extractor and the
storage object).</p>
<p>This completes the source code for our example.</p>
</div>
</div>
<div class="section" id="testing-your-extractor">
<h1><a class="toc-backref" href="#id13" name="testing-your-extractor">Testing Your Extractor</a></h1>
<p>Before setting up your Nabu publisher handler with the new extractor, you can
test it using the <tt class="docutils literal"><span class="pre">nabu-test-extractor</span></tt> code provided with Nabu (installed
under <tt class="docutils literal"><span class="pre">nabu/lib/python/nabu/testextr.py</span></tt>).</p>
<p>Run it like this, on a test document in reStructuredText format <tt class="docutils literal"><span class="pre">reading.txt</span></tt>,
which presumably contains book references (create your own test document with
your favourite books):</p>
<pre class="literal-block">
$ ./testextr.py book.py ~/reading.txt
</pre>
</div>
<div class="section" id="publisher-handler-configuration-code">
<h1><a class="toc-backref" href="#id14" name="publisher-handler-configuration-code">Publisher Handler Configuration Code</a></h1>
<p>The only part that remains to be done in order to feed a database with book
references is to configure your Nabu publisher handler with the new extractor.
The Nabu publisher handler is the script that you should install on your web
server to receive the source documents and run the extractors on them.  There is
an example publisher handler under <tt class="docutils literal"><span class="pre">nabu/cgi-bin/nabu-publish-handler.cgi</span></tt> in
the source distribution.</p>
<p>First import your extractor code at the top of the file:</p>
<pre class="literal-block">
...
import book
...
</pre>
<p>Then add the new extractor to the list of transforms that the server will be
configured with:</p>
<pre class="literal-block">
transforms = (
    ...
    (book.BookExtractor, book.BookStorage(connection)),
    )
</pre>
<p>(The connection object here is the SQLObject connection that has been created
previously in the script.  It is used by the <tt class="docutils literal"><span class="pre">SQLObjectExtractorStorage</span></tt> to
initialize the schema objects connections.)</p>
</div>
<div class="section" id="complete-source-code">
<h1><a class="toc-backref" href="#id15" name="complete-source-code">Complete Source Code</a></h1>
<p>The complete source code for the book example is reproduced here for
convenience:</p>
<pre class="literal-block">
#!/usr/bin/env python
&quot;&quot;&quot;
Extract book entries.
&quot;&quot;&quot;

# other imports
from sqlobject import *

# nabu imports
from nabu import extract
from nabu.extractors.flvis import FieldListVisitor


class BookExtractor(extract.Extractor):
    &quot;&quot;&quot;
    Transform that looks at field lists and that heuristically attempts
    to find references to books.  For example,

      :title: National Geographic Photography Field Guide 2nd Edition:
              Secrets to Making Great Pictures
      :author: Peter Burian, Bob Caputo
      :url: http://www.amazon.com/o/ASIN/079225676X/
      :review:

        Excellent diversified advice from top photographers.  The book
        manages to pack lots of relevant content in a small format.  It
        contains a nice section on composition, which is what originally
        attracted me to it.  As per usual, I found the digital
        photography section useless, but for the most part, the
        information available in this book is of great value.  This is
        the best general book about photography that I've read.

    The heuristic looks at an empty :book: field, an :ISBN: field, or
    some list that has an author and a title. See the Book class below to
    find out which fields are stored.
    &quot;&quot;&quot;

    default_priority = 900

    def apply( self, **kwargs ):
        self.unid, self.storage = kwargs['unid'], kwargs['storage']

        v = FieldListVisitor(self.document)
        v.initialize()
        self.document.walk(v)
        v.finalize()

        for flist in v.getfieldlists():
            book = 0
            # if there is an empty book field, this is explicitly a book.
            if 'book' in flist and not flist['book'].strip():
                book = 1
            # if there is an ISBN number, then it is *definitely* a book.
            elif 'isbn' in flist:
                book = 1
            # if there is an author and a title
            elif 'author' in flist and 'title' in flist:
                book = 1

            if book:
                self.store(flist) # store the book

    def store( self, flist ):
        emap = {}
        for k, v in flist.iteritems():
            emap[k] = v.astext()

        self.storage.store(self.unid, emap)


class Book(SQLObject):
    &quot;&quot;&quot;
    Storage for book information.
    &quot;&quot;&quot;
    unid = StringCol(notNull=1)

    title = UnicodeCol()
    author = UnicodeCol()
    year = UnicodeCol()
    url = UnicodeCol()
    review = UnicodeCol()


class BookStorage(extract.SQLObjectExtractorStorage):
    &quot;&quot;&quot;
    Book storage.
    &quot;&quot;&quot;

    sqlobject_classes = [Book]

    def store( self, unid, *args ):
        data, = args
        Book( unid=unid,
              title=data.get('title', ''),
              author=data.get('author'),
              year=data.get('year', ''),
              url=data.get('url', ''),
              review=data.get('review', '') )
</pre>
</div>
<div class="section" id="final-notes">
<h1><a class="toc-backref" href="#id16" name="final-notes">Final Notes</a></h1>
<p>Certainly, some improvements could be applied to the example we provide.  The
extractor could use a more sophisticated heuristic to determine if the field
list represents a book, parse various formats for the ISBN value so that it is
normalized and can then be used to automatically look up details from a URL on
some external website, we could convert and store the extracted values in BibTeX
format for later reuse, add more fields to the schema, parse not just generic
field lists, but also bibliographic fields of documents to allow them to enter a
book entry as well, etc.  This would not be difficult at all.</p>
<p>As you can see, writing extractors is very easy.  You can create as many
extractors as you want.  Nabu comes with a small library of extractors which
will grow as I leverage it more and more for my own applications, and with
contribution from other people if they care to send them to me.</p>
<p>You can find other extractors--including this one--in the Nabu source
distribution under <tt class="docutils literal"><span class="pre">nabu/lib/python/nabu/extractors</span></tt>.</p>
<p>If you have found any part of this document unclear and you still do not
understand the nature of Nabu after reading this example, please feel free to
contact the author with questions.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id3">[1]</a></td><td>If the field list appears at the top of the document, it will have been
parsed by the bibliographic fields parser and thus the <tt class="docutils literal"><span class="pre">:author:</span></tt> field
will have been converted into an author node, and a tiny little bit more
work would have to be done to look into those fields if we want a book
reference to be specifiable at the top of the document as the
bibliographic field.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id4">[2]</a></td><td>The code for this class is very simple and you could write similar
utilities to enhance code reuse for detecting different generic patterns
of document structure.  See the <a class="reference" href="http://docutils.sourceforge.net/docs/ref/doctree.html">docutils document tree</a> document for
information about what kinds of nodes the document tree is made of.</td></tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
